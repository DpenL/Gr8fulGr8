library(tidyverse)
library(tidymodels)
library(lubridate)

set.seed(2022)

customers <- read_csv("customers.csv")

geo <- read_csv("geo.csv")

#read training set
trans_training <- read_csv("transactions.csv")
trans_training <- trans_training %>% filter(is.na(TEST_SET_ID))
#remove test_ID column from training set
trans_training <- trans_training %>% subset(select= - c(TEST_SET_ID))

### DATA PREPARATION on geo data

#if country were unknown we can't identify custome
#geo <- geo %>% filter(!is.na(COUNTRY))

### DATA PREPARATION on customer data

#fix casing for string attributes
customers <- customers %>% mutate_at(vars(OWNERSHIP, COUNTRY, CURRENCY), toupper)

#correct data types of nominal attributes, not best practice
customers <- customers %>% mutate(
  OWNERSHIP = as.factor(OWNERSHIP),
  COUNTRY = as.factor(COUNTRY),
  COUNTRY = as.factor(COUNTRY)
)

# remove \" from REV_CURRENT_YEAR and convert to numeric
customers <- (customers %>% mutate(REV_CURRENT_YEAR = gsub("\"", "", REV_CURRENT_YEAR)))
customers$REV_CURRENT_YEAR <- as.numeric(customers$REV_CURRENT_YEAR)

# convert CREATION_YEAR to date
customers$CREATION_YEAR <- gsub(pattern="[[:punct:]]", ":", customers$CREATION_YEAR)
customers$CREATION_YEAR <- as_date(customers$CREATION_YEAR, format="%d:%m:%Y")

### DATA PREPARATION on transaction data

#correct data types of nominal attributes, not best practice
trans_training <- trans_training %>% mutate(
  TECH = as.factor(TECH),
  BUSINESS_TYPE = as.factor(BUSINESS_TYPE),
  PRICE_LIST = as.factor(PRICE_LIST)
)

#omit rows with ISIC = NA or SALES_LOCATION = NA
trans_training <- trans_training %>% filter(!is.na(ISIC) & !is.na(SALES_LOCATION))

#map training labels -> 0/1
trans_training <- trans_training %>% mutate(OFFER_STATUS = toupper(OFFER_STATUS))
#new column mapping losses->0, wins->1
trans_training <- trans_training %>% mutate(OFFER_STATUS_BIN = case_when(
  OFFER_STATUS == "LOSE" ~ 0,
  OFFER_STATUS == "LOST" ~ 0,
  TRUE ~ 1),
  OFFER_STATUS_BIN = as.factor(OFFER_STATUS_BIN)
)
trans_training <- trans_training %>% subset(select= - c(OFFER_STATUS))

#remove \" from CUSTOMER and END_CUSTOMER values
trans_training <- trans_training %>% mutate(CUSTOMER = gsub("\"", "", CUSTOMER))
trans_training <- trans_training %>% mutate(END_CUSTOMER = gsub("\"", "", END_CUSTOMER))

#handle missing values in END_CUSTOMER: NA -> 0
trans_training <- trans_training %>% mutate(END_CUSTOMER = toupper(END_CUSTOMER))
trans_training <- trans_training %>% mutate(END_CUSTOMER = case_when(
  is.na(END_CUSTOMER) ~ "0", #unknown end customer
  END_CUSTOMER == "NO" ~ "0", #unknown end customer != customer TODO maybe handle this differently
  END_CUSTOMER == "YES" ~ CUSTOMER, #customer is end customer
  TRUE ~ END_CUSTOMER 
))

#convert datestrings to datetime
trans_training$MO_CREATED_DATE <- gsub(pattern="[[:punct:]]", ":", trans_training$MO_CREATED_DATE)
trans_training$SO_CREATED_DATE <- gsub(pattern="[[:punct:]]", ":", trans_training$SO_CREATED_DATE)

trans_training <- trans_training %>% mutate_at(vars(MO_CREATED_DATE, SO_CREATED_DATE), as_datetime)

# convert CUSTOMER IDs to numeric, unavailable values -> NA TODO: should these rows be ignored?
trans_training$CUSTOMER <- as.numeric(trans_training$CUSTOMER)
trans_training$END_CUSTOMER <- as.numeric(trans_training$END_CUSTOMER)

#merge geo data using SALES_LOCATION
trans_training_joint <- merge(x = trans_training, y=geo, by='SALES_LOCATION', all.x=TRUE)
View(trans_training_joint %>% summarise(across(.cols = everything(), .fns = ~sum(is.na(.)))))

### TRAINING

#train a random forest model
train_model <- rand_forest(mode = "classification", mtry = 3, trees = 500) %>%
  set_engine("ranger") %>%
  fit(
    as.factor(OFFER_STATUS_BIN) ~ OFFER_PRICE,
    data = trans_training
  )

pred <- predict(train_model, trans_training)
error_rate = nrow(trans_training %>% filter(as.character(OFFER_STATUS_BIN)!=pred))/nrow(trans_training)
error_rate 

